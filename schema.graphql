# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

type Epoch {
    epochId: Int!
    orderedTransactionRoot: String!
    preHash: String!
    proof: Proof!
    stateRoot: String!
    timestamp: DateTime!
    transactions(after: Int, before: Int, first: Int, last: Int, skip: Int): [Transaction!]!
    transactionsCount: Int!
    validatorVersion: String!
    validators(after: Int, before: Int, first: Int, last: Int, skip: Int): [Validator!]!
}

type Event {
    data: String!
    receipt: Receipt!
}

type Mutation {
    createOneEpoch(data: EpochCreateInput!): Epoch!
    createOneTransaction(data: TransactionCreateInput!): Transaction!
    createOneValidator(data: ValidatorCreateInput!): Validator!
}

type Proof {
    bitmap: String!
    epochHash: String!
    round: Int!
    signature: String!
}

type Query {
    epoch(where: EpochWhereUniqueInput!): Epoch
    epoches(after: Int, before: Int, first: Int, last: Int, orderBy: EpochOrderByInput, skip: Int, where: EpochWhereInput): [Epoch!]!
    transaction(where: TransactionWhereUniqueInput!): Transaction
    transactions(after: Int, before: Int, first: Int, last: Int, orderBy: TransactionOrderByInput, skip: Int, where: TransactionWhereInput): [Transaction!]!
    validator(where: ValidatorWhereUniqueInput!): Validator
}

type Receipt {
    cyclesUsed: String!
    epoch: Epoch!
    events(after: Int, before: Int, first: Int, last: Int, skip: Int): [Event!]!
    response: ReceiptResponse!
    transaction: Transaction!
}

type ReceiptResponse {
    isError: Boolean!
    ret: String!
}

type Transaction {
    cyclesLimit: String!
    cyclesPrice: String!
    epoch: Epoch!
    method: String!
    nonce: String!
    payload: String!
    pubkey: String!
    receipt: Receipt
    serviceName: String!
    signature: String!
    txHash: String!
}

type Validator {
    address: String!
    epoches(after: Int, before: Int, first: Int, last: Int, skip: Int): [Epoch!]!
    proposeWeight: Int!
    voteWeight: Int!
}

enum OrderByArg {
    asc
    desc
}

input BooleanFilter {
    equals: Boolean
    not: Boolean
}

input DateTimeFilter {
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: DateTime
    notIn: [DateTime!]
}

input EpochCreateInput {
    epochId: Int!
    orderRoot: String!
    preHash: String!
    proof: ProofCreateOneWithoutProofInput!
    proposer: String!
    receipts: ReceiptCreateManyWithoutReceiptsInput
    stateRoot: String!
    timestamp: DateTime!
    transactions: TransactionCreateManyWithoutTransactionsInput
    transactionsCount: Int!
    validatorVersion: String!
    validators: ValidatorCreateManyWithoutValidatorsInput
}

input EpochCreateManyWithoutEpochesInput {
    connect: [EpochWhereUniqueInput!]
    create: [EpochCreateWithoutValidatorsInput!]
}

input EpochCreateOneWithoutEpochInput {
    connect: EpochWhereUniqueInput
    create: EpochCreateWithoutReceiptsInput
}

input EpochCreateWithoutReceiptsInput {
    epochId: Int!
    orderRoot: String!
    preHash: String!
    proof: ProofCreateOneWithoutProofInput!
    proposer: String!
    stateRoot: String!
    timestamp: DateTime!
    transactions: TransactionCreateManyWithoutTransactionsInput
    transactionsCount: Int!
    validatorVersion: String!
    validators: ValidatorCreateManyWithoutValidatorsInput
}

input EpochCreateWithoutValidatorsInput {
    epochId: Int!
    orderRoot: String!
    preHash: String!
    proof: ProofCreateOneWithoutProofInput!
    proposer: String!
    receipts: ReceiptCreateManyWithoutReceiptsInput
    stateRoot: String!
    timestamp: DateTime!
    transactions: TransactionCreateManyWithoutTransactionsInput
    transactionsCount: Int!
    validatorVersion: String!
}

input EpochFilter {
    every: EpochWhereInput
    none: EpochWhereInput
    some: EpochWhereInput
}

input EpochOrderByInput {
    epochId: OrderByArg
    id: OrderByArg
    orderRoot: OrderByArg
    preHash: OrderByArg
    proposer: OrderByArg
    stateRoot: OrderByArg
    timestamp: OrderByArg
    transactionsCount: OrderByArg
    validatorVersion: OrderByArg
}

input EpochWhereInput {
    AND: [EpochWhereInput!]
    NOT: [EpochWhereInput!]
    OR: [EpochWhereInput!]
    epochId: IntFilter
    id: IntFilter
    orderRoot: StringFilter
    preHash: StringFilter
    proof: ProofWhereInput
    proposer: StringFilter
    receipts: ReceiptFilter
    stateRoot: StringFilter
    timestamp: DateTimeFilter
    transactions: TransactionFilter
    transactionsCount: IntFilter
    validatorVersion: StringFilter
    validators: ValidatorFilter
}

input EpochWhereUniqueInput {
    epochId: Int
    id: Int
}

input EventCreateManyWithoutEventsInput {
    connect: [EventWhereUniqueInput!]
    create: [EventCreateWithoutReceiptInput!]
}

input EventCreateWithoutReceiptInput {
    data: String!
    service: String!
}

input EventFilter {
    every: EventWhereInput
    none: EventWhereInput
    some: EventWhereInput
}

input EventWhereInput {
    AND: [EventWhereInput!]
    NOT: [EventWhereInput!]
    OR: [EventWhereInput!]
    data: StringFilter
    id: IntFilter
    receipt: ReceiptWhereInput
    service: StringFilter
}

input EventWhereUniqueInput {
    id: Int
}

input IntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: Int
    notIn: [Int!]
}

input ProofCreateOneWithoutProofInput {
    connect: ProofWhereUniqueInput
    create: ProofCreateWithoutEpochesInput
}

input ProofCreateWithoutEpochesInput {
    bitmap: String!
    epochHash: String!
    epochId: Int!
    round: Int!
    signature: String!
}

input ProofWhereInput {
    AND: [ProofWhereInput!]
    NOT: [ProofWhereInput!]
    OR: [ProofWhereInput!]
    bitmap: StringFilter
    epochHash: StringFilter
    epochId: IntFilter
    epoches: EpochFilter
    id: IntFilter
    round: IntFilter
    signature: StringFilter
}

input ProofWhereUniqueInput {
    id: Int
}

input ReceiptCreateManyWithoutReceiptsInput {
    connect: [ReceiptWhereUniqueInput!]
    create: [ReceiptCreateWithoutEpochInput!]
}

input ReceiptCreateOneWithoutReceiptInput {
    connect: ReceiptWhereUniqueInput
    create: ReceiptCreateWithoutTransactionInput
}

input ReceiptCreateWithoutEpochInput {
    cyclesUsed: String!
    events: EventCreateManyWithoutEventsInput
    response: ReceiptResponseCreateOneWithoutResponseInput!
    transaction: TransactionCreateOneWithoutTransactionInput!
}

input ReceiptCreateWithoutTransactionInput {
    cyclesUsed: String!
    epoch: EpochCreateOneWithoutEpochInput!
    events: EventCreateManyWithoutEventsInput
    response: ReceiptResponseCreateOneWithoutResponseInput!
}

input ReceiptFilter {
    every: ReceiptWhereInput
    none: ReceiptWhereInput
    some: ReceiptWhereInput
}

input ReceiptResponseCreateOneWithoutResponseInput {
    connect: ReceiptResponseWhereUniqueInput
    create: ReceiptResponseCreateWithoutReceiptInput
}

input ReceiptResponseCreateWithoutReceiptInput {
    isError: Boolean!
    ret: String!
}

input ReceiptResponseWhereInput {
    AND: [ReceiptResponseWhereInput!]
    NOT: [ReceiptResponseWhereInput!]
    OR: [ReceiptResponseWhereInput!]
    id: IntFilter
    isError: BooleanFilter
    receipt: ReceiptWhereInput
    ret: StringFilter
}

input ReceiptResponseWhereUniqueInput {
    id: Int
}

input ReceiptWhereInput {
    AND: [ReceiptWhereInput!]
    NOT: [ReceiptWhereInput!]
    OR: [ReceiptWhereInput!]
    cyclesUsed: StringFilter
    epoch: EpochWhereInput
    events: EventFilter
    id: IntFilter
    response: ReceiptResponseWhereInput
    transaction: TransactionWhereInput
}

input ReceiptWhereUniqueInput {
    id: Int
}

input StringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: String
    notIn: [String!]
    startsWith: String
}

input TransactionCreateInput {
    chainId: String!
    cyclesLimit: String!
    cyclesPrice: String!
    epoch: EpochCreateOneWithoutEpochInput!
    method: String!
    nonce: String!
    payload: String!
    pubkey: String!
    receipt: ReceiptCreateOneWithoutReceiptInput
    serviceName: String!
    signature: String!
    timeout: String!
    txHash: String!
}

input TransactionCreateManyWithoutTransactionsInput {
    connect: [TransactionWhereUniqueInput!]
    create: [TransactionCreateWithoutEpochInput!]
}

input TransactionCreateOneWithoutTransactionInput {
    connect: TransactionWhereUniqueInput
    create: TransactionCreateWithoutReceiptInput
}

input TransactionCreateWithoutEpochInput {
    chainId: String!
    cyclesLimit: String!
    cyclesPrice: String!
    method: String!
    nonce: String!
    payload: String!
    pubkey: String!
    receipt: ReceiptCreateOneWithoutReceiptInput
    serviceName: String!
    signature: String!
    timeout: String!
    txHash: String!
}

input TransactionCreateWithoutReceiptInput {
    chainId: String!
    cyclesLimit: String!
    cyclesPrice: String!
    epoch: EpochCreateOneWithoutEpochInput!
    method: String!
    nonce: String!
    payload: String!
    pubkey: String!
    serviceName: String!
    signature: String!
    timeout: String!
    txHash: String!
}

input TransactionFilter {
    every: TransactionWhereInput
    none: TransactionWhereInput
    some: TransactionWhereInput
}

input TransactionOrderByInput {
    chainId: OrderByArg
    cyclesLimit: OrderByArg
    cyclesPrice: OrderByArg
    id: OrderByArg
    method: OrderByArg
    nonce: OrderByArg
    payload: OrderByArg
    pubkey: OrderByArg
    serviceName: OrderByArg
    signature: OrderByArg
    timeout: OrderByArg
    txHash: OrderByArg
}

input TransactionWhereInput {
    AND: [TransactionWhereInput!]
    NOT: [TransactionWhereInput!]
    OR: [TransactionWhereInput!]
    chainId: StringFilter
    cyclesLimit: StringFilter
    cyclesPrice: StringFilter
    epoch: EpochWhereInput
    id: IntFilter
    method: StringFilter
    nonce: StringFilter
    payload: StringFilter
    pubkey: StringFilter
    receipt: ReceiptWhereInput
    serviceName: StringFilter
    signature: StringFilter
    timeout: StringFilter
    txHash: StringFilter
}

input TransactionWhereUniqueInput {
    id: Int
    txHash: String
}

input ValidatorCreateInput {
    address: String!
    epoches: EpochCreateManyWithoutEpochesInput
    proposeWeight: Int!
    voteWeight: Int!
}

input ValidatorCreateManyWithoutValidatorsInput {
    connect: [ValidatorWhereUniqueInput!]
    create: [ValidatorCreateWithoutEpochesInput!]
}

input ValidatorCreateWithoutEpochesInput {
    address: String!
    proposeWeight: Int!
    voteWeight: Int!
}

input ValidatorFilter {
    every: ValidatorWhereInput
    none: ValidatorWhereInput
    some: ValidatorWhereInput
}

input ValidatorWhereInput {
    AND: [ValidatorWhereInput!]
    NOT: [ValidatorWhereInput!]
    OR: [ValidatorWhereInput!]
    address: StringFilter
    epoches: EpochFilter
    id: IntFilter
    proposeWeight: IntFilter
    voteWeight: IntFilter
}

input ValidatorWhereUniqueInput {
    address: String
    id: Int
}


scalar DateTime