# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: Query
  mutation: Mutation
}

type Epoch {
  epochId: Int!
  orderedTransactionRoot: String!
  preHash: String!
  proof: Proof!
  stateRoot: String!
  timestamp: DateTime!
  transactions(
    after: ID
    before: ID
    first: Int
    last: Int
    skip: Int
  ): [Transaction!]!
  transactionsCount: Int!
  validatorVersion: String!
  validators(
    after: ID
    before: ID
    first: Int
    last: Int
    skip: Int
  ): [Validator!]!
}

type Mutation {
  createOneEpoch(data: EpochCreateInput!): Epoch!
  createOneTransaction(data: TransactionCreateInput!): Transaction!
  createOneValidator(data: ValidatorCreateInput!): Validator!
}

type Proof {
  bitmap: String!
  epochHash: String!
  round: Int!
  signature: String!
}

type Query {
  epoch(where: EpochWhereUniqueInput!): Epoch
  epoches(
    after: ID
    before: ID
    first: Int
    last: Int
    orderBy: EpochOrderByInput
    skip: Int
    where: EpochWhereInput
  ): [Epoch!]!
  transaction(where: TransactionWhereUniqueInput!): Transaction
  transactions(
    after: ID
    before: ID
    first: Int
    last: Int
    orderBy: TransactionOrderByInput
    skip: Int
    where: TransactionWhereInput
  ): [Transaction!]!
  validator(where: ValidatorWhereUniqueInput!): Validator
}

type Transaction {
  cyclesLimit: String!
  cyclesPrice: String!
  epoch: Epoch!
  method: String!
  nonce: String!
  payload: String!
  pubkey: String!
  serviceName: String!
  signature: String!
  txHash: String!
}

type Validator {
  address: String!
  epoches(after: ID, before: ID, first: Int, last: Int, skip: Int): [Epoch!]!
  proposeWeight: Int!
  voteWeight: Int!
}

enum OrderByArg {
  asc
  desc
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input EpochCreateInput {
  epochId: Int!
  id: ID
  orderRoot: String!
  preHash: String!
  proof: ProofCreateOneWithoutProofInput!
  proposer: String!
  stateRoot: String!
  timestamp: DateTime!
  transactions: TransactionCreateManyWithoutTransactionsInput
  transactionsCount: Int!
  validatorVersion: String!
  validators: ValidatorCreateManyWithoutValidatorsInput
}

input EpochCreateManyWithoutEpochesInput {
  connect: [EpochWhereUniqueInput!]
  create: [EpochCreateWithoutValidatorsInput!]
}

input EpochCreateOneWithoutEpochInput {
  connect: EpochWhereUniqueInput
  create: EpochCreateWithoutTransactionsInput
}

input EpochCreateWithoutTransactionsInput {
  epochId: Int!
  id: ID
  orderRoot: String!
  preHash: String!
  proof: ProofCreateOneWithoutProofInput!
  proposer: String!
  stateRoot: String!
  timestamp: DateTime!
  transactionsCount: Int!
  validatorVersion: String!
  validators: ValidatorCreateManyWithoutValidatorsInput
}

input EpochCreateWithoutValidatorsInput {
  epochId: Int!
  id: ID
  orderRoot: String!
  preHash: String!
  proof: ProofCreateOneWithoutProofInput!
  proposer: String!
  stateRoot: String!
  timestamp: DateTime!
  transactions: TransactionCreateManyWithoutTransactionsInput
  transactionsCount: Int!
  validatorVersion: String!
}

input EpochFilter {
  every: EpochWhereInput
  none: EpochWhereInput
  some: EpochWhereInput
}

input EpochOrderByInput {
  epochId: OrderByArg
  id: OrderByArg
  orderRoot: OrderByArg
  preHash: OrderByArg
  proposer: OrderByArg
  stateRoot: OrderByArg
  timestamp: OrderByArg
  transactionsCount: OrderByArg
  validatorVersion: OrderByArg
}

input EpochWhereInput {
  AND: [EpochWhereInput!]
  NOT: [EpochWhereInput!]
  OR: [EpochWhereInput!]
  epochId: IntFilter
  id: StringFilter
  orderRoot: StringFilter
  preHash: StringFilter
  proof: ProofWhereInput
  proposer: StringFilter
  stateRoot: StringFilter
  timestamp: DateTimeFilter
  transactions: TransactionFilter
  transactionsCount: IntFilter
  validatorVersion: StringFilter
  validators: ValidatorFilter
}

input EpochWhereUniqueInput {
  epochId: Int
  id: ID
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input ProofCreateOneWithoutProofInput {
  connect: ProofWhereUniqueInput
  create: ProofCreateWithoutEpochesInput
}

input ProofCreateWithoutEpochesInput {
  bitmap: String!
  epochHash: String!
  epochId: Int!
  id: ID
  round: Int!
  signature: String!
}

input ProofWhereInput {
  AND: [ProofWhereInput!]
  NOT: [ProofWhereInput!]
  OR: [ProofWhereInput!]
  bitmap: StringFilter
  epochHash: StringFilter
  epochId: IntFilter
  epoches: EpochFilter
  id: StringFilter
  round: IntFilter
  signature: StringFilter
}

input ProofWhereUniqueInput {
  id: ID
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

input TransactionCreateInput {
  chainId: String!
  cyclesLimit: String!
  cyclesPrice: String!
  epoch: EpochCreateOneWithoutEpochInput!
  id: ID
  method: String!
  nonce: String!
  payload: String!
  pubkey: String!
  serviceName: String!
  signature: String!
  timeout: String!
  txHash: String!
}

input TransactionCreateManyWithoutTransactionsInput {
  connect: [TransactionWhereUniqueInput!]
  create: [TransactionCreateWithoutEpochInput!]
}

input TransactionCreateWithoutEpochInput {
  chainId: String!
  cyclesLimit: String!
  cyclesPrice: String!
  id: ID
  method: String!
  nonce: String!
  payload: String!
  pubkey: String!
  serviceName: String!
  signature: String!
  timeout: String!
  txHash: String!
}

input TransactionFilter {
  every: TransactionWhereInput
  none: TransactionWhereInput
  some: TransactionWhereInput
}

input TransactionOrderByInput {
  chainId: OrderByArg
  cyclesLimit: OrderByArg
  cyclesPrice: OrderByArg
  id: OrderByArg
  method: OrderByArg
  nonce: OrderByArg
  payload: OrderByArg
  pubkey: OrderByArg
  serviceName: OrderByArg
  signature: OrderByArg
  timeout: OrderByArg
  txHash: OrderByArg
}

input TransactionWhereInput {
  AND: [TransactionWhereInput!]
  NOT: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  chainId: StringFilter
  cyclesLimit: StringFilter
  cyclesPrice: StringFilter
  epoch: EpochWhereInput
  id: StringFilter
  method: StringFilter
  nonce: StringFilter
  payload: StringFilter
  pubkey: StringFilter
  serviceName: StringFilter
  signature: StringFilter
  timeout: StringFilter
  txHash: StringFilter
}

input TransactionWhereUniqueInput {
  id: ID
  txHash: String
}

input ValidatorCreateInput {
  address: String!
  epoches: EpochCreateManyWithoutEpochesInput
  id: ID
  proposeWeight: Int!
  voteWeight: Int!
}

input ValidatorCreateManyWithoutValidatorsInput {
  connect: [ValidatorWhereUniqueInput!]
  create: [ValidatorCreateWithoutEpochesInput!]
}

input ValidatorCreateWithoutEpochesInput {
  address: String!
  id: ID
  proposeWeight: Int!
  voteWeight: Int!
}

input ValidatorFilter {
  every: ValidatorWhereInput
  none: ValidatorWhereInput
  some: ValidatorWhereInput
}

input ValidatorWhereInput {
  AND: [ValidatorWhereInput!]
  NOT: [ValidatorWhereInput!]
  OR: [ValidatorWhereInput!]
  address: StringFilter
  epoches: EpochFilter
  id: StringFilter
  proposeWeight: IntFilter
  voteWeight: IntFilter
}

input ValidatorWhereUniqueInput {
  address: String
  id: ID
}

scalar DateTime
