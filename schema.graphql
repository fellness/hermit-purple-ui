# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

type Account {
    address: String!
    transactions(after: Int, before: Int, first: Int, last: Int, skip: Int): [Transaction!]!
}

type Block {
    height: Int!
    orderedTransactionRoot: String!
    preHash: String!
    proof: Proof!
    stateRoot: String!
    timestamp: DateTime!
    transactions(after: Int, before: Int, first: Int, last: Int, skip: Int): [Transaction!]!
    transactionsCount: Int!
    validatorVersion: String!
    validators(after: Int, before: Int, first: Int, last: Int, skip: Int): [Validator!]!
}

type Event {
    data: String!
    receipt: Receipt!
}

type Mutation {
    createOneBlock(data: BlockCreateInput!): Block!
    createOneTransaction(data: TransactionCreateInput!): Transaction!
    createOneValidator(data: ValidatorCreateInput!): Validator!
}

type Proof {
    bitmap: String!
    blockHash: String!
    round: Int!
    signature: String!
}

type Query {
    account(where: AccountWhereUniqueInput!): Account
    accounts(after: Int, before: Int, first: Int, last: Int, orderBy: AccountOrderByInput, skip: Int, where: AccountWhereInput): [Account!]!
    block(where: BlockWhereUniqueInput!): Block
    blocks(after: Int, before: Int, first: Int, last: Int, orderBy: BlockOrderByInput, skip: Int, where: BlockWhereInput): [Block!]!
    receipt(where: ReceiptWhereUniqueInput!): Receipt
    receipts(after: Int, before: Int, first: Int, last: Int, orderBy: ReceiptOrderByInput, skip: Int, where: ReceiptWhereInput): [Receipt!]!
    transaction(where: TransactionWhereUniqueInput!): Transaction
    transactions(after: Int, before: Int, first: Int, last: Int, orderBy: TransactionOrderByInput, skip: Int, where: TransactionWhereInput): [Transaction!]!
    validator(where: ValidatorWhereUniqueInput!): Validator
}

type Receipt {
    block: Block!
    cyclesUsed: String!
    events(after: Int, before: Int, first: Int, last: Int, skip: Int): [Event!]!
    response: ReceiptResponse!
    transaction: Transaction!
}

type ReceiptResponse {
    isError: Boolean!
    ret: String!
}

type Transaction {
    account: Account!
    block: Block!
    cyclesLimit: String!
    cyclesPrice: String!
    method: String!
    nonce: String!
    payload: String!
    pubkey: String!
    receipt: Receipt
    serviceName: String!
    signature: String!
    txHash: String!
}

type Validator {
    address: String!
    blocks(after: Int, before: Int, first: Int, last: Int, skip: Int): [Block!]!
    proposeWeight: Int!
    voteWeight: Int!
}

enum OrderByArg {
    asc
    desc
}

input AccountCreateOneWithoutTransactionsInput {
    connect: AccountWhereUniqueInput
    create: AccountCreateWithoutTransactionsInput
}

input AccountCreateWithoutTransactionsInput {
    address: String!
}

input AccountOrderByInput {
    address: OrderByArg
    id: OrderByArg
}

input AccountWhereInput {
    AND: [AccountWhereInput!]
    NOT: [AccountWhereInput!]
    OR: [AccountWhereInput!]
    address: StringFilter
    id: IntFilter
    transactions: TransactionFilter
}

input AccountWhereUniqueInput {
    address: String
    id: Int
}

input BlockCreateInput {
    height: Int!
    orderRoot: String!
    preHash: String!
    proof: ProofCreateOneWithoutBlocksInput!
    proposer: String!
    receipts: ReceiptCreateManyWithoutBlockInput
    stateRoot: String!
    timestamp: DateTime!
    transactions: TransactionCreateManyWithoutBlockInput
    transactionsCount: Int!
    validatorVersion: String!
    validators: ValidatorCreateManyWithoutBlocksInput
}

input BlockCreateManyWithoutValidatorsInput {
    connect: [BlockWhereUniqueInput!]
    create: [BlockCreateWithoutValidatorsInput!]
}

input BlockCreateOneWithoutReceiptsInput {
    connect: BlockWhereUniqueInput
    create: BlockCreateWithoutReceiptsInput
}

input BlockCreateOneWithoutTransactionsInput {
    connect: BlockWhereUniqueInput
    create: BlockCreateWithoutTransactionsInput
}

input BlockCreateWithoutReceiptsInput {
    height: Int!
    orderRoot: String!
    preHash: String!
    proof: ProofCreateOneWithoutBlocksInput!
    proposer: String!
    stateRoot: String!
    timestamp: DateTime!
    transactions: TransactionCreateManyWithoutBlockInput
    transactionsCount: Int!
    validatorVersion: String!
    validators: ValidatorCreateManyWithoutBlocksInput
}

input BlockCreateWithoutTransactionsInput {
    height: Int!
    orderRoot: String!
    preHash: String!
    proof: ProofCreateOneWithoutBlocksInput!
    proposer: String!
    receipts: ReceiptCreateManyWithoutBlockInput
    stateRoot: String!
    timestamp: DateTime!
    transactionsCount: Int!
    validatorVersion: String!
    validators: ValidatorCreateManyWithoutBlocksInput
}

input BlockCreateWithoutValidatorsInput {
    height: Int!
    orderRoot: String!
    preHash: String!
    proof: ProofCreateOneWithoutBlocksInput!
    proposer: String!
    receipts: ReceiptCreateManyWithoutBlockInput
    stateRoot: String!
    timestamp: DateTime!
    transactions: TransactionCreateManyWithoutBlockInput
    transactionsCount: Int!
    validatorVersion: String!
}

input BlockFilter {
    every: BlockWhereInput
    none: BlockWhereInput
    some: BlockWhereInput
}

input BlockOrderByInput {
    height: OrderByArg
    id: OrderByArg
    orderRoot: OrderByArg
    preHash: OrderByArg
    proposer: OrderByArg
    stateRoot: OrderByArg
    timestamp: OrderByArg
    transactionsCount: OrderByArg
    validatorVersion: OrderByArg
}

input BlockWhereInput {
    AND: [BlockWhereInput!]
    NOT: [BlockWhereInput!]
    OR: [BlockWhereInput!]
    height: IntFilter
    id: IntFilter
    orderRoot: StringFilter
    preHash: StringFilter
    proof: ProofWhereInput
    proposer: StringFilter
    receipts: ReceiptFilter
    stateRoot: StringFilter
    timestamp: DateTimeFilter
    transactions: TransactionFilter
    transactionsCount: IntFilter
    validatorVersion: StringFilter
    validators: ValidatorFilter
}

input BlockWhereUniqueInput {
    height: Int
    id: Int
}

input BooleanFilter {
    equals: Boolean
    not: Boolean
}

input DateTimeFilter {
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: DateTime
    notIn: [DateTime!]
}

input EventCreateManyWithoutReceiptInput {
    connect: [EventWhereUniqueInput!]
    create: [EventCreateWithoutReceiptInput!]
}

input EventCreateWithoutReceiptInput {
    data: String!
    service: String!
}

input EventFilter {
    every: EventWhereInput
    none: EventWhereInput
    some: EventWhereInput
}

input EventWhereInput {
    AND: [EventWhereInput!]
    NOT: [EventWhereInput!]
    OR: [EventWhereInput!]
    data: StringFilter
    id: IntFilter
    receipt: ReceiptWhereInput
    service: StringFilter
}

input EventWhereUniqueInput {
    id: Int
}

input IntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: Int
    notIn: [Int!]
}

input ProofCreateOneWithoutBlocksInput {
    connect: ProofWhereUniqueInput
    create: ProofCreateWithoutBlocksInput
}

input ProofCreateWithoutBlocksInput {
    bitmap: String!
    blockHash: String!
    height: Int!
    round: Int!
    signature: String!
}

input ProofWhereInput {
    AND: [ProofWhereInput!]
    NOT: [ProofWhereInput!]
    OR: [ProofWhereInput!]
    bitmap: StringFilter
    blockHash: StringFilter
    blocks: BlockFilter
    height: IntFilter
    id: IntFilter
    round: IntFilter
    signature: StringFilter
}

input ProofWhereUniqueInput {
    id: Int
}

input ReceiptCreateManyWithoutBlockInput {
    connect: [ReceiptWhereUniqueInput!]
    create: [ReceiptCreateWithoutBlockInput!]
}

input ReceiptCreateOneWithoutTransactionInput {
    connect: ReceiptWhereUniqueInput
    create: ReceiptCreateWithoutTransactionInput
}

input ReceiptCreateWithoutBlockInput {
    cyclesUsed: String!
    events: EventCreateManyWithoutReceiptInput
    response: ReceiptResponseCreateOneWithoutReceiptInput!
    transaction: TransactionCreateOneWithoutReceiptInput!
}

input ReceiptCreateWithoutTransactionInput {
    block: BlockCreateOneWithoutReceiptsInput!
    cyclesUsed: String!
    events: EventCreateManyWithoutReceiptInput
    response: ReceiptResponseCreateOneWithoutReceiptInput!
}

input ReceiptFilter {
    every: ReceiptWhereInput
    none: ReceiptWhereInput
    some: ReceiptWhereInput
}

input ReceiptOrderByInput {
    cyclesUsed: OrderByArg
    id: OrderByArg
}

input ReceiptResponseCreateOneWithoutReceiptInput {
    connect: ReceiptResponseWhereUniqueInput
    create: ReceiptResponseCreateWithoutReceiptInput
}

input ReceiptResponseCreateWithoutReceiptInput {
    isError: Boolean!
    ret: String!
}

input ReceiptResponseWhereInput {
    AND: [ReceiptResponseWhereInput!]
    NOT: [ReceiptResponseWhereInput!]
    OR: [ReceiptResponseWhereInput!]
    id: IntFilter
    isError: BooleanFilter
    receipt: ReceiptWhereInput
    ret: StringFilter
}

input ReceiptResponseWhereUniqueInput {
    id: Int
}

input ReceiptWhereInput {
    AND: [ReceiptWhereInput!]
    NOT: [ReceiptWhereInput!]
    OR: [ReceiptWhereInput!]
    block: BlockWhereInput
    cyclesUsed: StringFilter
    events: EventFilter
    id: IntFilter
    response: ReceiptResponseWhereInput
    transaction: TransactionWhereInput
}

input ReceiptWhereUniqueInput {
    id: Int
}

input StringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: String
    notIn: [String!]
    startsWith: String
}

input TransactionCreateInput {
    account: AccountCreateOneWithoutTransactionsInput!
    block: BlockCreateOneWithoutTransactionsInput!
    chainId: String!
    cyclesLimit: String!
    cyclesPrice: String!
    method: String!
    nonce: String!
    payload: String!
    pubkey: String!
    receipt: ReceiptCreateOneWithoutTransactionInput
    serviceName: String!
    signature: String!
    timeout: String!
    txHash: String!
}

input TransactionCreateManyWithoutBlockInput {
    connect: [TransactionWhereUniqueInput!]
    create: [TransactionCreateWithoutBlockInput!]
}

input TransactionCreateOneWithoutReceiptInput {
    connect: TransactionWhereUniqueInput
    create: TransactionCreateWithoutReceiptInput
}

input TransactionCreateWithoutBlockInput {
    account: AccountCreateOneWithoutTransactionsInput!
    chainId: String!
    cyclesLimit: String!
    cyclesPrice: String!
    method: String!
    nonce: String!
    payload: String!
    pubkey: String!
    receipt: ReceiptCreateOneWithoutTransactionInput
    serviceName: String!
    signature: String!
    timeout: String!
    txHash: String!
}

input TransactionCreateWithoutReceiptInput {
    account: AccountCreateOneWithoutTransactionsInput!
    block: BlockCreateOneWithoutTransactionsInput!
    chainId: String!
    cyclesLimit: String!
    cyclesPrice: String!
    method: String!
    nonce: String!
    payload: String!
    pubkey: String!
    serviceName: String!
    signature: String!
    timeout: String!
    txHash: String!
}

input TransactionFilter {
    every: TransactionWhereInput
    none: TransactionWhereInput
    some: TransactionWhereInput
}

input TransactionOrderByInput {
    chainId: OrderByArg
    cyclesLimit: OrderByArg
    cyclesPrice: OrderByArg
    id: OrderByArg
    method: OrderByArg
    nonce: OrderByArg
    payload: OrderByArg
    pubkey: OrderByArg
    serviceName: OrderByArg
    signature: OrderByArg
    timeout: OrderByArg
    txHash: OrderByArg
}

input TransactionWhereInput {
    AND: [TransactionWhereInput!]
    NOT: [TransactionWhereInput!]
    OR: [TransactionWhereInput!]
    account: AccountWhereInput
    block: BlockWhereInput
    chainId: StringFilter
    cyclesLimit: StringFilter
    cyclesPrice: StringFilter
    id: IntFilter
    method: StringFilter
    nonce: StringFilter
    payload: StringFilter
    pubkey: StringFilter
    receipt: ReceiptWhereInput
    serviceName: StringFilter
    signature: StringFilter
    timeout: StringFilter
    txHash: StringFilter
}

input TransactionWhereUniqueInput {
    id: Int
    txHash: String
}

input ValidatorCreateInput {
    address: String!
    blocks: BlockCreateManyWithoutValidatorsInput
    proposeWeight: Int!
    voteWeight: Int!
}

input ValidatorCreateManyWithoutBlocksInput {
    connect: [ValidatorWhereUniqueInput!]
    create: [ValidatorCreateWithoutBlocksInput!]
}

input ValidatorCreateWithoutBlocksInput {
    address: String!
    proposeWeight: Int!
    voteWeight: Int!
}

input ValidatorFilter {
    every: ValidatorWhereInput
    none: ValidatorWhereInput
    some: ValidatorWhereInput
}

input ValidatorWhereInput {
    AND: [ValidatorWhereInput!]
    NOT: [ValidatorWhereInput!]
    OR: [ValidatorWhereInput!]
    address: StringFilter
    blocks: BlockFilter
    id: IntFilter
    proposeWeight: IntFilter
    voteWeight: IntFilter
}

input ValidatorWhereUniqueInput {
    address: String
    id: Int
}


scalar DateTime